from TranslationExtractor import PE
from tkinter import *
from tkinter.ttk import *
from tkinter import filedialog
import lxml.etree as ET
from file import BFS, listdir_abspath
import os

def output(result: dict[str, ET._ElementTree], output_dir: str):
    for defType, tree in result.items():
        elemroot: ET._Element = tree.getroot()
        os.makedirs(f"{output_dir}/{defType}", exist_ok=True)
        base_filename = f"{output_dir}/{defType}/Extracted"
        ext = ".xml"
        for node in list(elemroot):
            if node.text == "" or node.text is None:
                root.remove(node)
        if os.path.exists(f"{base_filename}{ext}"):
            current = ET.parse(f"{base_filename}{ext}").getroot()
            for child in list(elemroot):
                current.append(child)
            current.write(
                f"{base_filename}{ext}",
                pretty_print=True,
                xml_declaration=True,
                encoding="utf-8",
            )
        else:
            tree.write(
                f"{base_filename}{ext}",
                pretty_print=True,
                xml_declaration=True,
                encoding="utf-8",
            )


def extract(ext_dir: str, recursive: bool, split: bool, append: bool):
    Label(Patch_Extract, text=f"Extracting from {ext_dir}...").grid()
    files = BFS(ext_dir, ["xml"]) if recursive else listdir_abspath(ext_dir, ["xml"])
    if split:
        output_dir = filedialog.askdirectory(mustexist=True, title="保存到……")
        for file in files:
            result = PE.extract([file])
            for defType, KVpair in result.items():
                elemroot: ET._Element = ET.Element("LanguageData")
                elemroot.addprevious(
                    ET.Comment("This file was generated by Patch_Extract.py")
                )
                tree: ET._ElementTree = ET.ElementTree(elemroot)
                basename = os.path.basename(os.path.dirname(file))
                file_name = (
                    os.path.basename(file).split(".")[0]
                    + (f"_{basename}" if append else "")
                    + ".xml"
                )
                os.makedirs(f"{output_dir}/{defType}", exist_ok=True)
                for key, value in KVpair.items():
                    defName = ET.SubElement(elemroot, key)
                    defName.addprevious(ET.Comment("EN: " + value)) # Add original text as comment
                    defName.text = value
                print(f"{output_dir}/{defType}/{file_name}")
                tree.write(
                    f"{output_dir}/{defType}/{file_name}",
                    pretty_print=True,
                    xml_declaration=True,
                    encoding="utf-8",
                )

    else:
        results = PE.extract(files)
        Label(Patch_Extract, text="Extraction complete!").grid()
        output_dir = filedialog.askdirectory(mustexist=True, title="保存到……")
        if output_dir != "":
            for defType, result in results.items():
                elemroot: ET._Element = ET.Element("LanguageData")
                elemroot.addprevious(
                    ET.Comment("This file was generated by Patch_Extract.py")
                )
                etree: ET._ElementTree = ET.ElementTree(elemroot)
                for key, value in result.items():
                    defName = ET.SubElement(elemroot, key)
                    defName.addprevious(ET.Comment("EN: " + value))
                    defName.text = value
                output({defType: etree}, output_dir)


def Patch_Extract_Tab(Tab: Frame):
    ext_dir = StringVar(Tab, value="undefined", name="ext_dir")
    ext_dir.trace_add(
        "write",
        lambda a, b, c: (
            ext_button.config(state="normal")
            if ext_dir.get() != "undefined"
            else ext_button.config(state="disabled")
        ),
    )
    directory_label_text = StringVar(
        Tab, value=f"The directory of the patch is: {ext_dir.get()}"
    )
    directory_label = Label(
        Tab, textvariable=directory_label_text, wraplength=800
    )
    directory_label.grid()
    Button(
        Tab,
        text="Choose directory",
        command=lambda: (
            ext_dir.set(
                filedialog.askdirectory(mustexist=True, title="选择目标文件夹")
            ),
            directory_label_text.set(f"The directory of patches is: {ext_dir.get()}"),
        ),
    ).grid()
    recursive_var = BooleanVar(Tab, True)
    append_var = BooleanVar(Tab, False)
    split_var = BooleanVar(Tab, False)
    split_var.trace_add(
        "write",
        lambda a, b, c: (
            append_option.config(state="normal")
            if split_var.get()
            else append_option.config(state="disabled")
        ),
    )
    Checkbutton(Tab, text="Recursive", variable=recursive_var).grid()
    Label(Tab, text="递归查找").grid()
    Checkbutton(Tab, text="File Specific", variable=split_var).grid()
    Label(Tab, text="按文件分割").grid()
    append_option = Checkbutton(
        Tab, text="Append", variable=append_var, state="disabled"
    )
    append_option.grid()
    Label(Tab, text="追加文件夹名到文件名后").grid()
    ext_button = Button(
        Tab, text="Extract!", command=lambda: extract(ext_dir.get(), recursive_var.get(), split_var.get(), append_var.get()), state="disabled"
    )
    ext_button.grid()

class Test_Tab():
    _singleton = None

    def __new__(cls, Tab: Widget):
        if Test_Tab._singleton is None:
            Test_Tab._singleton = super(Test_Tab, cls).__new__(cls)
        return Test_Tab._singleton

    def __init__(self, Tab: Widget):
        self.dirs = []
        self.buttons = []
        self.data_vars = []
        self.Tab = Tab
        self.Frame_int1 = Frame(Test, width=Test.winfo_reqwidth())
        self.Frame_int1.grid(row=0, sticky='nswe', columnspan=2)
        self.Frame_Checkboxes = Frame(Test)
        self.Frame_Checkboxes.grid(row=1, column=0, sticky='nswe')
        self.Frame_Config = Frame(Test)
        self.Frame_Config.grid(row=1, column=1, sticky='nswe')
        self.Frame_int3 = Frame(Test, width=Test.winfo_reqwidth())
        self.Frame_int3.grid(row=2, sticky= 'nswe', columnspan=2)
        self.Tab.rowconfigure(0, weight=1)
        self.Tab.rowconfigure(1, weight=8)
        self.Tab.columnconfigure(1, weight=2)
        self.Tab.columnconfigure(0, weight=8)
        self.Tab.rowconfigure(2, weight=1)
        self.canvas = Canvas(self.Frame_Checkboxes)
        self.scrbr = Scrollbar(self.Frame_Checkboxes, orient=VERTICAL, command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.scrbr.set, scrollregion=self.canvas.bbox("all"))
        self.canvas.bind_all("<MouseWheel>", self.on_mousewheel)
        self.Frame_Checkboxes.grid_rowconfigure(0, weight=1)
        self.Frame_Checkboxes.grid_columnconfigure(0, weight=1)
        self.ext_dir = StringVar(Test, name="ext_dir1")
        self.ext_dir.trace_add('write', self.update)
        Button(
            self.Frame_int1,
            text="Choose directory",
            command=lambda: (
                self.ext_dir.set(
                    filedialog.askdirectory(mustexist=True, title="选择目标文件夹")
                ),
                self.update()
            )
        ).place(relx=0.5, rely=0.5, anchor=CENTER)
        self.update()
    
    def on_mousewheel(self, event):
        self.canvas.yview_scroll(-1 * (event.delta // 120), "units")

    def update(self, *args):
        if not self.ext_dir.get(): return
        self.dirs.clear()
        self.data_vars.clear()
        for button in self.buttons:
            button.destroy()
        self.canvas.delete('all')
        self.Checkboxes = Frame(self.canvas)
        self.canvas.create_window((0, 0), window=self.Checkboxes, anchor="nw")
        row = 1
        self.dirs.extend([f"{self.ext_dir.get()}/{f}" for f in os.listdir(self.ext_dir.get()) if os.path.isdir(f"{self.ext_dir.get()}/{f}") and not (f[0] == "." or f[0] == "_")])
        self.data_vars.extend([IntVar(Test, 0) for i in range(len(self.dirs))])
        for i in range(len(self.dirs)):
            button = Checkbutton(self.Checkboxes, text=self.dirs[i], variable=self.data_vars[i], name=f"dir{i}")
            button.grid(row=i+row, column=0, sticky='we')
            self.Checkboxes.grid_rowconfigure(0, weight=1)
            self.buttons.append(button)
            row += 1
        #Frame_Checkboxes.rowconfigure(row+len(dirs)+1)
        Button(self.Frame_int3, text="Output Selected", command=lambda: print([f for f in self.dirs if self.data_vars[self.dirs.index(f)].get()]), name="output").place(relx=0.5, rely=0.5, anchor=CENTER)
        self.Checkboxes.update_idletasks()
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        self.canvas.grid(row=0, column=0, sticky='nswe')
        self.scrbr.grid(row=0, column=1, sticky='ns')


    def Draw(self, *args):
        pass




if __name__ == "__main__":
    def update_all(*args):
        print(args)
        root.update()
    root = Tk()
    Style().configure("Red.TFrame", background="red")
    Style().configure("Blue.TFrame", background="blue")
    Style().configure("Green.TFrame", background="green")
    Style().configure('yellow.TFrame', background='yellow')
    Style().configure('white.TFrame', background='white')
    root.title("Pyscripts")
    root.geometry("800x600")
    root.resizable(False, False)
    notebook = Notebook(root, width=800, height=600)
    Patch_Extract = Frame(notebook)
    Translation_Clean = Frame(notebook)
    Test = Frame(notebook)
    notebook.add(Patch_Extract, text="Patch Extractor")
    # notebook.add(Translation_Clean, text="Translation Cleaner")
    notebook.add(Test, text="Test")
    notebook.bind("<<NotebookTabChanged>>", update_all)
    notebook.pack()
    Patch_Extract_Tab(Patch_Extract)
    Test_Tab(Test)
    root.mainloop()
