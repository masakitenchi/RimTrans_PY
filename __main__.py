from TranslationExtractor import PE
from tkinter import *
from tkinter.ttk import *
from tkinter import filedialog
import lxml.etree as ET
from file import BFS, listdir_abspath
import os

class Patch_Extract_Tab_Deprecated(Frame):

    _singleton = None
    def __new__(cls, Tab: Widget):
        if Patch_Extract_Tab_Deprecated._singleton is None:
            Patch_Extract_Tab_Deprecated._singleton = super(Patch_Extract_Tab_Deprecated, cls).__new__(cls)
        return Patch_Extract_Tab_Deprecated._singleton
    
    def __init__(self, Tab: Widget):
        self.Tab = Tab
        self.ext_dir = StringVar(Tab, value="undefined", name="ext_dir")
        self.ext_dir.trace_add(
            "write",
            lambda a, b, c: (
                self.ext_button.config(state="normal")
                if self.ext_dir.get() != "undefined"
                else self.ext_button.config(state="disabled")
            ),
        )
        self.directory_label_text = StringVar(
            Tab, value=f"The directory of the patch is: {self.ext_dir.get()}"
        )
        self.directory_label = Label(
            Tab, textvariable=self.directory_label_text, wraplength=800
        )
        self.directory_label.grid()
        Button(
            Tab,
            text="Choose directory",
            command=lambda: (
                self.ext_dir.set(
                    filedialog.askdirectory(mustexist=True, title="选择目标文件夹")
                ),
                self.directory_label_text.set(f"The directory of patches is: {self.ext_dir.get()}"),
            ),
        ).grid()
        self.recursive_var = BooleanVar(Tab, True)
        self.append_var = BooleanVar(Tab, False)
        self.split_var = BooleanVar(Tab, False)
        self.split_var.trace_add(
            "write",
            lambda a, b, c: (
                self.append_option.config(state="normal")
                if self.split_var.get()
                else self.append_option.config(state="disabled")
            ),
        )
        Checkbutton(Tab, text="Recursive", variable=self.recursive_var).grid()
        Label(Tab, text="递归查找").grid()
        Checkbutton(Tab, text="File Specific", variable=self.split_var).grid()
        Label(Tab, text="按文件分割").grid()
        self.append_option = Checkbutton(
            Tab, text="Append", variable=self.append_var, state="disabled"
        )
        self.append_option.grid()
        Label(Tab, text="追加文件夹名到文件名后").grid()
        self.ext_button = Button(
            Tab, text="Extract!", command=lambda: self.extract(self.ext_dir.get(), self.recursive_var.get(), self.split_var.get(), self.append_var.get()), state="disabled"
        )
        self.ext_button.grid()

    def extract(self, ext_dir: str, recursive: bool, split: bool, append: bool):
        Label(self.Tab, text=f"Extracting from {ext_dir}...").grid()
        files = BFS(ext_dir, ["xml"]) if recursive else listdir_abspath(ext_dir, ["xml"])
        if split:
            output_dir = filedialog.askdirectory(mustexist=True, title="保存到……")
            for file in files:
                result = PE.extract([file])
                for defType, KVpair in result.items():
                    elemroot: ET._Element = ET.Element("LanguageData")
                    elemroot.addprevious(
                        ET.Comment("This file was generated by Patch_Extract.py")
                    )
                    tree: ET._ElementTree = ET.ElementTree(elemroot)
                    basename = os.path.basename(os.path.dirname(file))
                    file_name = (
                        os.path.basename(file).split(".")[0]
                        + (f"_{basename}" if append else "")
                        + ".xml"
                    )
                    os.makedirs(f"{output_dir}/{defType}", exist_ok=True)
                    for key, value in KVpair.items():
                        defName = ET.SubElement(elemroot, key)
                        defName.addprevious(ET.Comment("EN: " + value)) # Add original text as comment
                        defName.text = value
                    print(f"{output_dir}/{defType}/{file_name}")
                    tree.write(
                        f"{output_dir}/{defType}/{file_name}",
                        pretty_print=True,
                        xml_declaration=True,
                        encoding="utf-8",
                    )

        else:
            results = PE.extract(files)
            Label(self.Tab, text="Extraction complete!").grid()
            output_dir = filedialog.askdirectory(mustexist=True, title="保存到……")
            if output_dir != "":
                for defType, result in results.items():
                    elemroot: ET._Element = ET.Element("LanguageData")
                    elemroot.addprevious(
                        ET.Comment("This file was generated by Patch_Extract.py")
                    )
                    etree: ET._ElementTree = ET.ElementTree(elemroot)
                    for key, value in result.items():
                        defName = ET.SubElement(elemroot, key)
                        defName.addprevious(ET.Comment("EN: " + value))
                        defName.text = value
                    self.output({defType: etree}, output_dir)
    
    @staticmethod
    def output(result: dict[str, ET._ElementTree], output_dir: str):
        for defType, tree in result.items():
            elemroot: ET._Element = tree.getroot()
            os.makedirs(f"{output_dir}/{defType}", exist_ok=True)
            base_filename = f"{output_dir}/{defType}/Extracted"
            ext = ".xml"
            for node in list(elemroot):
                if node.text == "" or node.text is None:
                    elemroot.remove(node)
            if os.path.exists(f"{base_filename}{ext}"):
                current = ET.parse(f"{base_filename}{ext}").getroot()
                for child in list(elemroot):
                    current.append(child)
                current.write(
                    f"{base_filename}{ext}",
                    pretty_print=True,
                    xml_declaration=True,
                    encoding="utf-8",
                )
            else:
                tree.write(
                    f"{base_filename}{ext}",
                    pretty_print=True,
                    xml_declaration=True,
                    encoding="utf-8",
                )





class Patch_Extract_Tab(Frame):
    _singleton = None

    def __new__(cls, Tab: Widget):
        if Patch_Extract_Tab._singleton is None:
            Patch_Extract_Tab._singleton = super(Patch_Extract_Tab, cls).__new__(cls)
        return Patch_Extract_Tab._singleton

    def __init__(self, Tab: Widget):
        super().__init__(Tab)
        self.dirs = []
        self.DirOptions = []
        self.data_vars = []
        self.Tab = Tab
        self.Title = Frame(Tab, width=Tab.winfo_reqwidth(), height=20, style='white.TFrame')
        self.Title.grid(row=0, sticky='nswe', columnspan=2)
        self.Title.grid_rowconfigure(0, minsize=100)
        self.Main_Rect = Frame(Tab, style='Green.TFrame')
        self.Main_Rect.grid(row=1, column=0, sticky='nswe')
        self.Frame_Config = Frame(Tab, style='yellow.TFrame', width=200)
        self.Frame_Config.grid(row=1, column=1, sticky='nswe')
        self.Draw_config(self.Frame_Config)
        self.Bottom_Buttons = Frame(Tab, width=Tab.winfo_reqwidth(), height=20, style='Blue.TFrame')
        self.Bottom_Buttons.grid(row=2, sticky= 'nswe', columnspan=2)
        self.Tab.rowconfigure(0, minsize=40, pad=10)
        self.Tab.rowconfigure(1, weight=1)
        self.Tab.rowconfigure(2, minsize=40, pad=10)
        self.Tab.columnconfigure(1, weight=2, minsize = 50)
        self.Tab.columnconfigure(0, weight=8)
        self.canvas = Canvas(self.Main_Rect)
        self.scrbrY = Scrollbar(self.Main_Rect, orient=VERTICAL, command=self.canvas.yview)
        self.scrbrX = Scrollbar(self.Main_Rect, orient=HORIZONTAL, command=self.canvas.xview)
        self.canvas.configure(xscrollcommand=self.scrbrX.set, yscrollcommand=self.scrbrY.set, scrollregion=self.canvas.bbox("all"))
        self.Main_Rect.grid_rowconfigure(0, weight=1)
        self.Main_Rect.grid_columnconfigure(0, weight=1)
        self.ext_dir = StringVar(Tab, name="ext_dir1")
        self.ext_dir.trace_add('write', self.update)
        Button(
            self.Title,
            text="Choose directory",
            command=lambda: (
                self.ext_dir.set(
                    filedialog.askdirectory(mustexist=True, title="选择目标文件夹")
                )
            )
        ).place(relx=0.5, rely=0.5, anchor=CENTER)
        """ self.entry = Entry(Tab)
        def execute(event):
            command = self.entry.get()
            print(eval(command))
        self.entry.bind("<Return>", execute)
        self.entry.grid(row=2, column=1, sticky='we') """
        self.update()
    
    def on_mousewheel(self, event):
        #print(self.canvas.xview(), self.canvas.yview())
        self.canvas.yview_scroll(-1 * (event.delta // 120), "units")

    def update(self, *args):
        if not self.ext_dir.get(): return
        self.Main_Rect.update_idletasks()
        self.dirs.clear()
        self.data_vars.clear()
        for button in self.DirOptions:
            button.destroy()
        self.canvas.delete('all')
        self.Checkboxes = Frame(self.canvas)
        self.canvas.create_window((0, 0), window=self.Checkboxes, anchor="nw")
        row = 1
        self.dirs.extend([f"{self.ext_dir.get()}/{f}" for f in os.listdir(self.ext_dir.get()) if os.path.isdir(f"{self.ext_dir.get()}/{f}") and not (f[0] == "." or f[0] == "_")])
        self.data_vars.extend([IntVar(self.Tab, 0) for i in range(len(self.dirs))])
        for i in range(len(self.dirs)):
            button = Checkbutton(self.Checkboxes, text=self.dirs[i], variable=self.data_vars[i], name=f"dir{i}")
            button.grid(row=i+row, column=0, sticky='we')
            #print(button.winfo_reqwidth())
            self.DirOptions.append(button)
            row += 1
        Button(self.Bottom_Buttons, text="Output Selected", command=self.do_work, name="output").place(relx=0.5, rely=0.5, anchor=CENTER)
        # update must be placed before actually drawing (e.g. with grid or pack) the widgets
        # I'm still confused by how this actually works
        self.canvas.update_idletasks()
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))
        self.canvas.grid(sticky='nswe')
        if self.canvas.bbox('all')[2] > self.Main_Rect.winfo_reqwidth() + 20:
            self.scrbrX.grid(row=1, column=0, sticky='we')
        else:
            self.scrbrX.grid_forget()
        if self.canvas.bbox('all')[3] > self.Main_Rect.winfo_reqheight():
            self.canvas.bind_all("<MouseWheel>", self.on_mousewheel)
            self.scrbrY.grid(row=0, column=1, sticky='ns')
        else:
            self.canvas.unbind_all("<MouseWheel>")
            self.scrbrY.grid_forget()

    def Draw_config(self, outRect: Widget, **kwargs):
        self.configBoxes = []
        self.recursive = BooleanVar(self.Tab, True)
        self.append = BooleanVar(self.Tab, False)
        self.split = BooleanVar(self.Tab, False)
        self.split.trace_add(
            "write",
            lambda a, b, c: (
                self.append_option.config(state="normal")
                if self.split.get()
                else (self.append_option.config(state="disabled"), self.append.set(False))
            ),
        )
        outRect.rowconfigure(0, weight=1)
        outRect.columnconfigure(0, weight=1)
        inRect = Frame(outRect)
        inRect.rowconfigure(0, weight=1)
        inRect.columnconfigure(0, weight=1)
        inRect.grid(row=0, column=0)
        self.recursive_option = Checkbutton(inRect, text="Recursive", variable=self.recursive)
        self.recursive_option.grid(row=0, column=0, sticky='w')
        self.split_option = Checkbutton(inRect, text="Split", variable=self.split)
        self.split_option.grid(row=1, column=0, sticky='w')
        self.append_option = Checkbutton(inRect, text="Append", variable=self.append, state="disabled")
        self.append_option.grid(row=2,column=0, sticky='w')

    def do_work(self):
        dirs = (dirname for i, dirname in enumerate(self.dirs) if self.data_vars[i].get())
        recursive = self.recursive.get()
        split = self.split.get()
        append = self.append.get()
        Total_dir = filedialog.askdirectory(mustexist=True, title="保存到……")
        for dir in dirs:
            mod_name = os.path.basename(dir)
            output_dir = f"{Total_dir}/{mod_name}/Languages/ChineseSimplified/DefInjected"
            os.makedirs(output_dir, exist_ok=True)
            files = []
            for file in (BFS(dir, ["xml"]) if recursive else listdir_abspath(dir, ["xml"])):
                try:
                    root = ET.parse(file).getroot()
                    if not(root.tag == "Defs" or root.tag == "Patch"):
                        continue
                    files.append(file)
                except:
                    continue
            
            #print(f'result: {files}')
            if split:
                for file in files:
                    KVpair = PE.extract([file])
                    for defType, KVpair in KVpair.items():
                        elemroot: ET._Element = ET.Element("LanguageData")
                        elemroot.addprevious(
                            ET.Comment("This file was generated by Patch_Extract.py")
                        )
                        tree: ET._ElementTree = ET.ElementTree(elemroot)
                        basename = os.path.basename(os.path.dirname(file))
                        file_name = (
                            os.path.basename(file).split(".")[0]
                            + (f"_{basename}" if append else "")
                            + ".xml"
                        )
                        #os.makedirs(os.path.join(output_dir, defType), exist_ok=True)
                        os.makedirs(os.path.join(output_dir, defType, 'Defs'), exist_ok=True)
                        os.makedirs(os.path.join(output_dir, defType, 'Patches'), exist_ok=True)
                        for key, value in KVpair.items():
                            if value == "" or value is None: continue
                            defName = ET.SubElement(elemroot, key)
                            defName.addprevious(ET.Comment("EN: " + value)) # Add original text as comment
                            defName.text = value
                        #print(f"{output_dir}/{defType}/{file_name}")
                        if 'Defs' in file:
                            tree.write(
                                f"{output_dir}/{defType}/Defs/{file_name}",
                                pretty_print=True,
                                xml_declaration=True,
                                encoding="utf-8",
                            )
                        elif 'Patches' in file:
                            tree.write(
                                f"{output_dir}/{defType}/Patches/{file_name}",
                                pretty_print=True,
                                xml_declaration=True,
                                encoding="utf-8",
                            )
                        else:
                            tree.write(
                                f"{output_dir}/{defType}/{file_name}",
                                pretty_print=True,
                                xml_declaration=True,
                                encoding="utf-8",
                            )
            else:
                results = PE.extract(files)
                for defType, KVpair in results.items():
                    os.makedirs(os.path.join(output_dir, defType), exist_ok=True)
                    elemroot: ET._Element = ET.Element("LanguageData")
                    elemroot.addprevious(
                        ET.Comment("This file was generated by Patch_Extract.py")
                    )
                    etree: ET._ElementTree = ET.ElementTree(elemroot)
                    for key, value in KVpair.items():
                        if value == "" or value is None: continue
                        defName = ET.SubElement(elemroot, key)
                        defName.addprevious(ET.Comment("EN: " + value))
                        defName.text = value
                    etree.write(f'{output_dir}/{defType}/Extracted_Unified.xml', pretty_print=True, xml_declaration=True, encoding='utf-8')
                      

class MainWindow(Tk):
    def __init__(self):
        super().__init__()
        Style().configure("Red.TFrame", background="red", theme='vista')
        Style().configure("Blue.TFrame", background="blue", theme='vista')
        Style().configure("Green.TFrame", background="green", theme='vista')
        Style().configure('yellow.TFrame', background='yellow', theme='vista')
        Style().configure('white.TFrame', background='white', theme='vista')
        self.title("Pyscripts")
        self.geometry("800x600")
        self.resizable(True,True)
        self.notebook = Notebook(self, width=800, height=600)
        self.Patch_Extract = Frame(self.notebook)
        self.Patch_Extract.pack()
        self.Translation_Clean = Frame(self.notebook)
        self.Test = Frame(self.notebook, style='Red.TFrame', width=800, height=600)
        self.Test.pack()
        self.notebook.add(self.Test, text="Patch Extractor")
        #self.notebook.add(self.Translation_Clean, text="Translation Cleaner")
        self.notebook.add(self.Patch_Extract, text="Test")
        #self.notebook.bind("<<NotebookTabChanged>>", self.update_all)
        self.notebook.hide(self.notebook.index(self.Patch_Extract))
        self.notebook.pack()
        #Patch_Extract_Tab(self.Patch_Extract)
        self.Test_Tab = Patch_Extract_Tab(self.Test)

    def update_all(self, *args):
        print(args)
        self.update()


if __name__ == "__main__":
    app = MainWindow()
    Style(app).theme_use('vista')
    app.mainloop()
